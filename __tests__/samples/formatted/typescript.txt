import { Component } from '@alpha/test';
import b from '@beta/test';
import {
  c,
  d as NewComponent,
  d as FormApi,
} from 'common/library';
import { createRef, MutableRefObject, ReactElement, SetStateAction } from 'react';
import { CONST1, CONST2 } from '../shared/library';
import { useState, useEffect } from 'react';
import { FC } from 'react';
import './stylesheet.scss';
export enum MyEnum {
  Test1 = 'test1',
  Test2 = 'test2',
}

interface Props {
  a: boolean;
  b: boolean;
  c: boolean;
  d: boolean;
  load: () => void;
}

interface OtherProps {
  items: {isNew: boolean }[];
}

const MyComponent = (props): FC<Props> => {
  const [a, setA] = useState<boolean>(false);
  const [b, setA] = useState<{
      c: boolean;
      d: 'right' | 'left';
      e: boolean;
  }>({
              c: false,
              d: 'right',
              e: false,
          });
  const [f, setF] = useState<boolean>(false);
  const [g, setG] = useState<boolean>(null);
  const [h, setH] = useState<MyEnum>(MyEnum.Test1);
  const [i, setI] = useState<boolean>(props.a !== 'YES' &&
              props.b !== 'YES' &&
              props.c !== 'YES' &&
              props.d !== 'YES');
  const [j, setJ] = useState<{ items: string[]; ignore: { items: string[] } }>({ items: [], ignore: { items: [] } });
  // This is a comment that I find useful for this variable
  // Let's see what's its use
  let myVariable: MutableRefObject<FormApi<{
      x: string;
  }> | null> = createRef();

  let anotherRef: MutableRefObject<Function | null> = createRef();
  // @todo: Review content of this effect
  useEffect(() => {
    document.title = props.t('my.id');
    const { a } = props.match.params;

    loadData(a);
    window.addEventListener('onload', loadWindow);

    return () => {
      window.removeEventListener('onload', loadWindow);
    }
  }, []);

  const loadWindow = (): void => {
      // @todo Refactor this method using new states and consider using
      // \`use-immer\` hook instead of \`produce\` if setState is using it.
      // Also, consider creating new effects if the state has a callback after the setter
      setState((prevState) => ({
          ...prevState,
          a: MyEnum.Test2,
          b: null,
          c: 'en-US',
      }));
  };

  // @todo: Review content of this effect
  useEffect(() => {
      const { a: prevProp } = prevProps.match.params;
      const { b: prevState } = props.match.params;

      if (a !== b) {
        // @todo Refactor this method using new states and consider using
        // \`use-immer\` hook instead of \`produce\` if setState is using it.
        // Also, consider creating new effects if the state has a callback after the setter
        setState((prevState) => ({
          ...prevState,
          a: false,
        }));
      }

      if (
          prevStates.a !== a ||
          prevState.b !== b ||
          prevState.c !== c
      ) {
          // @todo Refactor this method using new states and consider using
          // \`use-immer\` hook instead of \`produce\` if setState is using it.
          // Also, consider creating new effects if the state has a callback after the setter
          setState(
              (prevState) => ({ ...prevState, f: true }),
              () => props.load()
          );
      }
  });

  /**
    * This is a long description
    *
    * 
    * @param param1 Unknow string
    * @return void
    */
  const moreDetails = (
      param1: MyEnum,
      param2?: boolean,
      param3: string = 'en-US'
  ): void => {
      // @todo Refactor this method using new states and consider using
      // \`use-immer\` hook instead of \`produce\` if setState is using it.
      // Also, consider creating new effects if the state has a callback after the setter
      setState(
          produce(state, (draftState): void => {
              draftState.a = param1;
              draftState.b = false;
              draftState.c = param3;
          })
      );
  };

  ///-------------Function - start
  const loadData = async (result): Promise<void> => {
    props.load();
    // @todo Refactor this method using new states and consider using
    // `use-immer` hook instead of `produce` if setState is using it.
    // Also, consider creating new effects if the state has a callback after the setter
    setState({ j: result });
  };

  ///-------------Function - End

  const list = ['apple', 'banana'];
  const {
      b,
      f: f1,
  } = state;
  const {
      a,
      b,
      c,
  } = props;

  const internalMethod = () => {
    const myObj = {
        x: a,
        y: b,
        z: c,
    };

    // @todo Refactor this method using new states and consider using
    // \`use-immer\` hook instead of \`produce\` if setState is using it.
    // Also, consider creating new effects if the state has a callback after the setter
    setState(
        produce(state, (draftState): void => {
            draftState.j = f1 || 'YES';
        }),
        () => {
            loadData(MyEnum.Test2);
        }
    );
  };
  const internalVar = () => getResult(c);

  return (
    <>
        {/* HTML ------------------------ > Start */}
        {!readOnlyMode && isDcfClosed && (
            <div>
                <h3>This is a Component</h3>
                <button onClick={alertName}>
                Alert
                </button>
            </div>
        )}
        {/* HTML ------------------------ > End */}
    </>
  );
}

const isNew = (x: OtherProps): boolean => {
    return (x.items, { isNew: true });
};

export default MyComponent;
